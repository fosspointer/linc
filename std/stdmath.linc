#guard

gen<T> fn abs(number: T) {
    zero := as T(0);
    if number > zero number else - number
}

gen<T, U> fn lerp(start: T, end: T, position: U) {
    one := as U(1);
    as T(as U(start) * (one - position)) + as T(position * as U(end))
}

gen<T> fn min(first: T, second: T)
    if first < second first else second

gen<T> fn max(first: T, second: T)
    if first > second first else second

gen<T> fn floor(number: T) {
    zero := as T(0);
    one := as T(1);
    mod: T = number % one;
    if number >= zero number - mod
    else if mod == zero number
    else number - mod - one
}

gen<T> fn ceil(number: T) {
    zero := as T(0);
    one := as T(1);
    mod: T = number % one;
    if number <= zero number - mod
    else if mod == zero number
    else number - mod + one
}

gen<T> fn round(number: T) {
    zero := as T(0);
    half := as T(0.5);
    if number > zero { floor<T>(number + half) } else { ceil<T>(number - half) }
}

piF32 := 3.14159265358979323846264338327950288f32
piF64 := 3.14159265358979323846264338327950288f64